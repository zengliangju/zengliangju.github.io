{"meta":{"title":"我的博客","subtitle":"","description":"","author":"孤影","url":"https://zengliangju.github.io","root":"/"},"posts":[{"tags":[],"title":"","date":"2023/10/24","text":"!c::Send, ^&#123;Insert&#125;!v::Send, +&#123;Insert&#125;!x::Send, ^&#123;x&#125;!z::Send, ^&#123;z&#125;!a::Send, ^&#123;a&#125;!s::Send, ^&#123;s&#125;!w::Send, ^&#123;w&#125;!t::Send, ^&#123;t&#125;!f::Send, ^&#123;f&#125;!1::Send, ^+&#123;Tab&#125;!2::Send, ^&#123;Tab&#125;!b::Send, ^&#123;b&#125;!p::Send, ^&#123;p&#125;","permalink":"https://zengliangju.github.io/2023/10/24/windows/autohotkey/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"}],"title":"C++ protobuf 的原理及优点","date":"2020/06/14","text":"转自https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html，侵删！ 1. 优点 简单，使用的时候只需要包含编译好的 h、cpp 文件 快，二进制存储，比 xml 小 3 到 10 倍，比 xml 快 20 到 100 倍 向后兼容，新协议的数据包可以被老协议解析 2. 原理2.1 Encoding​ Protobuf 序列化后所生成的二进制消息非常紧凑，这得益于 Protobuf 采用的非常巧妙的 Encoding 方法。 ​ 考察消息结构之前，让我首先要介绍一个叫做 Varint 的术语。 ​ Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。 ​ 比如对于 int32 类型的数字，一般需要 4 个 byte 来表示。但是采用 Varint，对于很小的 int32 类型的数字，则可以用 1 个 byte 来表示。当然凡事都有好的也有不好的一面，采用 Varint 表示法，大的数字则需要 5 个 byte 来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用 Varint 后，可以用更少的字节数来表示数字信息。下面就详细介绍一下 Varint。 ​ Varint 中的每个 byte 的最高位 bit 有特殊的含义，如果该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示：1010 1100 0000 0010 ​ 下图演示了 Google Protocol Buffer 如何解析两个 bytes。注意到最终计算前将两个 byte 的位置相互交换过一次，这是因为 Google Protocol Buffer 字节序采用 little-endian 的方式。 消息经过序列化后会成为一个二进制数据流，该流中的数据为一系列的 Key-Value 对。如下图所示： ​ 采用这种 Key-Pair 结构无需使用分隔符来分割不同的 Field。对于可选的 Field，如果消息中不存在该 field，那么在最终的 Message Buffer 中就没有该 field，这些特性都有助于节约消息本身的大小。 ​ Key 用来标识具体的 field，在解包的时候，Protocol Buffer 根据 Key 就可以知道相应的 Value 应该对应于消息中的哪一个 field。 ​ Key 的定义：(field_number &lt;&lt; 3) | wire_type ​ 可以看到 Key 由两部分组成。第一部分是 field_number，比如消息 lm.helloworld 中 field id 的 field_number 为 1。第二部分为 wire_type。表示 Value 的传输类型。 ​ Wire Type 可能的类型如下表所示： Type Meaning Used for 0 Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64-bit fixed64, sfixed64, double 2 Length-delimi string, bytes, embedded messages, packed repeated fields 3 Start group Groups (deprecated) 4 End group Groups (deprecated) 5 32-bit fixed32, sfixed32, float ​ 细心的读者或许会看到在 Type 0 所能表示的数据类型中有 int32 和 sint32 这两个非常类似的数据类型。Google Protocol Buffer 区别它们的主要意图也是为了减少 encoding 后的字节数。 ​ 在计算机内，一个负数一般会被表示为一个很大的整数，因为计算机定义负数的符号位为数字的最高位。如果采用 Varint 表示一个负数，那么一定需要 5 个 byte。为此 Google Protocol Buffer 定义了 sint32 这种类型，采用 zigzag 编码。 ​ Zigzag 编码用无符号数来表示有符号数字，正数和负数交错，这就是 zigzag 这个词的含义了。 ​ 如图所示： ​ 使用 zigzag 编码，绝对值小的数字，无论正负都可以采用较少的 byte 来表示，充分利用了 Varint 这种技术。 ​ 其他的数据类型，比如字符串等则采用类似数据库中的 varchar 的表示方法，即用一个 varint 表示长度，然后将其余部分紧跟在这个长度部分之后即可。 2.2 Decoding​ 首先我们来了解一下 XML 的封解包过程。XML 需要从文件中读取出字符串，再转换为 XML 文档对象结构模型。之后，再从 XML 文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将 XML 文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗 CPU 的复杂计算。 ​ 反观 Protobuf，它只需要简单地将一个二进制序列，按照指定的格式读取到 C++ 对应的结构类型中就可以了。从上一节的描述可以看到消息的 decoding 过程也可以通过几个位移操作组成的表达式计算即可完成。速度非常快。","permalink":"https://zengliangju.github.io/2020/06/14/c++/10_protobuf/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"}],"title":"C++ brpc server","date":"2020/06/14","text":"to be continued.","permalink":"https://zengliangju.github.io/2020/06/14/c++/7_brpc_server/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"}],"title":"C++ boost asio","date":"2020/06/14","text":"to be continued.","permalink":"https://zengliangju.github.io/2020/06/14/c++/8_boost_asio/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"}],"title":"C++ marco 字符串拼接","date":"2020/06/14","text":"#a：将 a 的内容以字符串的形式拼接到代码中 fun##a：将 a 的内容和 fun 拼接在一起 // main.cpp#include &lt;iostream&gt;// 制造函数工厂并使用它#define FUNCTION(name, a) int fun_##name() &#123; return a;&#125;FUNCTION(abcd, 12)FUNCTION(fff, 2)FUNCTION(qqq, 23)#undef FUNCTION#define FUNCTION 34#define OUTPUT(a) std::cout &lt;&lt; &quot;output: &quot; #a &lt;&lt; &#x27;\\n&#x27;int main()&#123; std::cout &lt;&lt; &quot;abcd: &quot; &lt;&lt; fun_abcd() &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; &quot;fff: &quot; &lt;&lt; fun_fff() &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; &quot;qqq: &quot; &lt;&lt; fun_qqq() &lt;&lt; &#x27;\\n&#x27;; std::cout &lt;&lt; FUNCTION &lt;&lt; &#x27;\\n&#x27;; OUTPUT(million); // 注意缺少引号&#125; 编译、运行 [root] g++ main.cpp ; ./a.outabcd: 12fff: 2qqq: 2334output: million","permalink":"https://zengliangju.github.io/2020/06/14/c++/9_marco/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"},{"name":"Linux","slug":"Linux","permalink":"https://zengliangju.github.io/tags/Linux/"}],"title":"Linux C++ perf 性能分析","date":"2020/06/14","text":"perf：用于分析 C++ 程序性能分析，可以定位到耗时最多的函数 // main.cppvoid longa()&#123; int i,j; for(i = 0; i &lt; 1000000; i++) j=i; //am I silly or crazy? I feel boring and desperate.&#125;void foo2()&#123; int i; for(i=0 ; i &lt; 10; i++) longa();&#125;void foo1()&#123; int i; for(i = 0; i&lt; 100; i++) longa();&#125;int main(void)&#123; foo1(); foo2();&#125; 编译、运行 [root] g++ -g main.cpp[root] perf record -e cpu-clock -g ./a.out[root] perf reportSamples: 1K of event &#x27;cpu-clock:u&#x27;, Event count (approx.): 290250000 Children Self Command Shared Object Symbol+ 99.74% 99.74% a.out a.out [.] longa+ 99.74% 0.00% a.out libc-2.17.so [.] __libc_start_main+ 99.74% 0.00% a.out a.out [.] main+ 90.53% 0.00% a.out a.out [.] foo1+ 9.22% 0.00% a.out a.out [.] foo2 0.26% 0.00% a.out ld-2.17.so [.] _dl_sysdep_start 0.26% 0.00% a.out ld-2.17.so [.] dl_main 0.17% 0.17% a.out ld-2.17.so [.] _dl_lookup_symbol_x 0.17% 0.09% a.out ld-2.17.so [.] _dl_relocate_object 0.09% 0.00% a.out libc-2.17.so [.] _dl_vdso_vsym","permalink":"https://zengliangju.github.io/2020/06/14/linux/8_perf/","photos":[]},{"tags":[{"name":"ES","slug":"ES","permalink":"https://zengliangju.github.io/tags/ES/"}],"title":"Elasticsearch docker stack 集群部署","date":"2020/06/14","text":"docker-compose.yml version: &#x27;2.2&#x27;services: es01: image: docker.elastic.co/elasticsearch/elasticsearch:7.5.2 container_name: es01 environment: - node.name=es01 - cluster.name=es-docker-cluster - discovery.seed_hosts=es02,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data01:/usr/share/elasticsearch/data ports: - 9200:9200 networks: - elastic es02: image: docker.elastic.co/elasticsearch/elasticsearch:7.5.2 container_name: es02 environment: - node.name=es02 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es03 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data02:/usr/share/elasticsearch/data networks: - elastic es03: image: docker.elastic.co/elasticsearch/elasticsearch:7.5.2 container_name: es03 environment: - node.name=es03 - cluster.name=es-docker-cluster - discovery.seed_hosts=es01,es02 - cluster.initial_master_nodes=es01,es02,es03 - bootstrap.memory_lock=true - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; ulimits: memlock: soft: -1 hard: -1 volumes: - data03:/usr/share/elasticsearch/data networks: - elasticvolumes: data01: driver: local data02: driver: local data03: driver: localnetworks: elastic: driver: bridge 创建&#x2F;启动集群 docker-compose up 测试结果 curl -X GET &quot;localhost:9200/_cat/nodes?v&amp;pretty&quot; 停止集群 docker-compose down","permalink":"https://zengliangju.github.io/2020/06/14/es/1_docker_stack/","photos":[]},{"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zengliangju.github.io/tags/Linux/"}],"title":"Linux trap","date":"2020/06/14","text":"trap：用于 shell 脚本中捕获信号，可用于 shell 脚本异常情况时的清理工作 touch test.txt# SIGINT Ctrl+Ctrap &#x27;rm ./test.txt ; exit 1&#x27; SIGINTwhile :do sleep 60done","permalink":"https://zengliangju.github.io/2020/06/14/linux/6_trap/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"},{"name":"Linux","slug":"Linux","permalink":"https://zengliangju.github.io/tags/Linux/"}],"title":"Linux C++ valgrind 内存分析","date":"2020/06/14","text":"valgrind：用于分析 C++ 程序内存使用的异常情况，比如内存泄漏、越界访问、未初始化 // main.cpp#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;using namespace std;void print_usage(char * argv) &#123; cout &lt;&lt; &quot;usage: &quot; &lt;&lt; argv &lt;&lt; &quot; 1|2|3&quot; &lt;&lt; endl;&#125;// 内存泄漏void f1() &#123; int *array = (int *)malloc(sizeof(int));&#125;// 越界访问void f2() &#123; vector&lt;int&gt; v(10, 0); cout &lt;&lt; v[10] &lt;&lt; endl;&#125;// 未初始化void f3() &#123; int x; if (x == 0) &#123; std::cout &lt;&lt; &quot;X is zero&quot; &lt;&lt; std::endl; &#125;&#125;int main(int argc, char* argv[]) &#123; if (argc &lt; 2) &#123; print_usage(argv[0]); return -1; &#125; switch (atoi(argv[1])) &#123; case 1: f1(); break; case 2: f2(); break; case 3: f3(); break; default: print_usage(argv[0]); break; &#125; return 0;&#125; 编译、运行 [root] # 需要 -g 编译，才能使用 valgrind[root] g++ -g main.cpp[root] # 内存泄漏，提示 definitely lost: 4 bytes in 1 blocks[root] valgrind --tool=memcheck --leak-check=full ./a.out 1==24313== Memcheck, a memory error detector==24313== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.==24313== Using Valgrind-3.16.0 and LibVEX; rerun with -h for copyright info==24313== Command: ./a.out 1==24313== ==24313== ==24313== HEAP SUMMARY:==24313== in use at exit: 4 bytes in 1 blocks==24313== total heap usage: 1 allocs, 0 frees, 4 bytes allocated==24313== ==24313== 4 bytes in 1 blocks are definitely lost in loss record 1 of 1==24313== at 0x4C29F33: malloc (vg_replace_malloc.c:307)==24313== by 0x400AD4: f1() (main.cpp:13)==24313== by 0x400C0B: main (main.cpp:38)==24313== ==24313== LEAK SUMMARY:==24313== definitely lost: 4 bytes in 1 blocks==24313== indirectly lost: 0 bytes in 0 blocks==24313== possibly lost: 0 bytes in 0 blocks==24313== still reachable: 0 bytes in 0 blocks==24313== suppressed: 0 bytes in 0 blocks==24313== ==24313== For lists of detected and suppressed errors, rerun with: -s==24313== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)[root] # 越界访问，提示 Invalid read of size 4[root] valgrind --tool=memcheck --leak-check=full ./a.out 2==24463== Memcheck, a memory error detector==24463== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.==24463== Using Valgrind-3.16.0 and LibVEX; rerun with -h for copyright info==24463== Command: ./a.out 2==24463== ==24463== Invalid read of size 4==24463== at 0x400B2A: f2() (main.cpp:19)==24463== by 0x400C12: main (main.cpp:41)==24463== Address 0x5a23068 is 0 bytes after a block of size 40 alloc&#x27;d==24463== at 0x4C2A553: operator new(unsigned long) (vg_replace_malloc.c:342)==24463== by 0x4010B5: __gnu_cxx::new_allocator&lt;int&gt;::allocate(unsigned long, void const*) (new_allocator.h:104)==24463== by 0x400FB2: std::_Vector_base&lt;int, std::allocator&lt;int&gt; &gt;::_M_allocate(unsigned long) (stl_vector.h:168)==24463== by 0x400E90: void std::vector&lt;int, std::allocator&lt;int&gt; &gt;::_M_initialize_dispatch&lt;int&gt;(int, int, std::__true_type) (stl_vector.h:1163)==24463== by 0x400CFA: std::vector&lt;int, std::allocator&lt;int&gt; &gt;::vector&lt;int&gt;(int, int, std::allocator&lt;int&gt; const&amp;) (stl_vector.h:404)==24463== by 0x400B0C: f2() (main.cpp:18)==24463== by 0x400C12: main (main.cpp:41)==24463== 0==24463== ==24463== HEAP SUMMARY:==24463== in use at exit: 0 bytes in 0 blocks==24463== total heap usage: 1 allocs, 1 frees, 40 bytes allocated==24463== ==24463== All heap blocks were freed -- no leaks are possible==24463== ==24463== For lists of detected and suppressed errors, rerun with: -s==24463== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)[root] # 未初始化，提示 Conditional jump or move depends on uninitialised value(s)[root] valgrind --tool=memcheck --leak-check=full ./a.out 3==24572== Memcheck, a memory error detector==24572== Copyright (C) 2002-2017, and GNU GPL&#x27;d, by Julian Seward et al.==24572== Using Valgrind-3.16.0 and LibVEX; rerun with -h for copyright info==24572== Command: ./a.out 3==24572== ==24572== Conditional jump or move depends on uninitialised value(s)==24572== at 0x400B9A: f3() (main.cpp:25)==24572== by 0x400C19: main (main.cpp:44)==24572== X is zero==24572== ==24572== HEAP SUMMARY:==24572== in use at exit: 0 bytes in 0 blocks==24572== total heap usage: 0 allocs, 0 frees, 0 bytes allocated==24572== ==24572== All heap blocks were freed -- no leaks are possible==24572== ==24572== Use --track-origins=yes to see where uninitialised values come from==24572== For lists of detected and suppressed errors, rerun with: -s==24572== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)","permalink":"https://zengliangju.github.io/2020/06/14/linux/7_valgrind/","photos":[]},{"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zengliangju.github.io/tags/Linux/"}],"title":"Linux awk","date":"2020/06/14","text":"[root] awk -F&#x27; &#x27; &#x27;&#123;printf &quot;%-5s\\t%-5s\\n&quot;,$2,$1&#125;&#x27; file.txt1 zeng 3 liang2 ju file.txt zeng 1liang 3ju 2","permalink":"https://zengliangju.github.io/2020/06/14/linux/5_awk/","photos":[]},{"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zengliangju.github.io/tags/Linux/"}],"title":"Linux sed","date":"2020/06/14","text":"-i 直接修改文件内容，慎用！ [root] # sed -i &#x27;s/要被取代的字串/新的字串/g&#x27; # -i 直接修改文件内容[root] # sed &#x27;s/要被取代的字串/新的字串/g&#x27;[root] sed &#x27;s/root/zeng/g&#x27; file.txtzeng:x:0:0:zeng:/zeng:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologinoperator:x:11:0:operator:/zeng:/sbin/nologin file.txt root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin","permalink":"https://zengliangju.github.io/2020/06/14/linux/4_sed/","photos":[]},{"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zengliangju.github.io/tags/Linux/"}],"title":"Linux cut","date":"2020/06/13","text":"-s 不打印没有包含分界符的行，如果不加该参数，则会输出不包含分界符的行 [root] cut -s -d &#x27; &#x27; -f 2 file.txt13 file.txt zeng 1liang 3ju","permalink":"https://zengliangju.github.io/2020/06/13/linux/3_cut/","photos":[]},{"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zengliangju.github.io/tags/Linux/"}],"title":"Linux sort","date":"2020/06/13","text":"[root] sort -k 2 -n file.txtzeng 1ju 2liang 3 file.txt zeng 1liang 3ju 2","permalink":"https://zengliangju.github.io/2020/06/13/linux/2_sort/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"}],"title":"C++ epoll","date":"2020/06/13","text":"epoll的优点 fd上限。支持的fd上限是最大可以打开文件的数目，这个数字一般远大于select的1024； 事件通知。通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知，而非select、poll的轮询机制； 减少内存拷贝。只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果）。select或poll一样每次都把current轮流加入fd对应的设备等待队列中。 epoll的实现 // server.cpp#include &lt;sys/epoll.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;cassert&gt;#include &lt;fcntl.h&gt;#include &lt;netinet/in.h&gt;#include &lt;cstring&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;#define MAX_EVENTS 10bool setnonblocking(int sd);void do_use_fd(int fd);int main() &#123; struct epoll_event ev, events[MAX_EVENTS]; int listen_sock, conn_sock, nfds, epollfd; /* Code to set up listening socket, &#x27;listen_sock&#x27;, (socket(), bind(), listen()) omitted */ &#123; const char* ip = &quot;0.0.0.0&quot;; int port = 36363; sockaddr_in addr; memset(&amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); if(inet_aton(ip, &amp;addr.sin_addr) == 0) return -1; // create socket if((listen_sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) return -1; if(!setnonblocking(listen_sock)) return -1; // bind socket if(bind(listen_sock, (sockaddr*)&amp;addr, sizeof(addr)) != 0) &#123; shutdown(listen_sock, 2); close(listen_sock); return -1; &#125; // listen if(listen(listen_sock, 10) != 0) &#123; shutdown(listen_sock, 2); close(listen_sock); return -1; &#125; &#125; epollfd = epoll_create1(0); if (epollfd == -1) &#123; perror(&quot;epoll_create1&quot;); exit(EXIT_FAILURE); &#125; ev.events = EPOLLIN; ev.data.fd = listen_sock; if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == -1) &#123; perror(&quot;epoll_ctl: listen_sock&quot;); exit(EXIT_FAILURE); &#125; for (;;) &#123; nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1); if (nfds == -1) &#123; perror(&quot;epoll_wait&quot;); exit(EXIT_FAILURE); &#125; for (int n = 0; n &lt; nfds; ++n) &#123; if (events[n].data.fd == listen_sock) &#123; struct sockaddr addr; socklen_t addrlen; conn_sock = accept(listen_sock, (struct sockaddr *) &amp;addr, &amp;addrlen); if (conn_sock == -1) &#123; perror(&quot;accept&quot;); exit(EXIT_FAILURE); &#125; setnonblocking(conn_sock); ev.events = EPOLLIN | EPOLLET; ev.data.fd = conn_sock; if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, &amp;ev) == -1) &#123; perror(&quot;epoll_ctl: conn_sock&quot;); exit(EXIT_FAILURE); &#125; &#125; else &#123; do_use_fd(events[n].data.fd); &#125; &#125; &#125;&#125;bool setnonblocking(int sd) &#123; assert(sd &gt;= 0); return fcntl(sd, F_SETFL, fcntl(sd, F_GETFD, 0) | O_NONBLOCK) == 0;&#125;void do_use_fd(int fd) &#123; std::cout &lt;&lt; &quot;fd: &quot; &lt;&lt; fd &lt;&lt; std::endl; shutdown(fd, 2); close(fd);&#125; // client.cpp#include &lt;arpa/inet.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;unistd.h&gt;#include &lt;netdb.h&gt;#include &lt;strings.h&gt;#ifndef ADDRESS#define ADDRESS &quot;127.0.0.1&quot;#endif#ifndef PORT#define PORT 36363#endifint main() &#123; int ret = 0; int conn_fd; if ((conn_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) &#123; perror(&quot;Socket&quot;); return -1; &#125; struct sockaddr_in server_addr = &#123; 0 &#125;; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(PORT); ret = inet_pton(AF_INET, ADDRESS, &amp;server_addr.sin_addr); if (ret != 1) &#123; if (ret == -1) &#123; perror(&quot;inet_pton&quot;); &#125; fprintf(stderr, &quot;failed to convert address %s &quot; &quot;to binary net address\\n&quot;, ADDRESS); return -1; &#125; fprintf(stdout, &quot;CONNECTING: address=%s port=%d\\n&quot;, ADDRESS, PORT); ret = connect(conn_fd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)); if (ret == -1) &#123; perror(&quot;connect&quot;); return -1; &#125; // After the connection has been properly established, we could go // forward with `read(2)` and `write(2)` calls. ret = shutdown(conn_fd, SHUT_RDWR); if (ret == -1) &#123; perror(&quot;shutdown&quot;); return -1; &#125; ret = close(conn_fd); if (ret == -1) &#123; perror(&quot;close&quot;); return -1; &#125; return 0;&#125; 编译 [1] g++ server.cpp -o server.o[1] ./server.o [2] g++ client.cpp -o client.o[2] ./client.o 输出 [1] fd: 5 [2] ONNECTING: address=127.0.0.1 port=36363","permalink":"https://zengliangju.github.io/2020/06/13/c++/6_epoll/","photos":[]},{"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zengliangju.github.io/tags/Linux/"}],"title":"Linux 清空日志文件","date":"2020/05/09","text":"&gt; /tmp/a.log","permalink":"https://zengliangju.github.io/2020/05/09/linux/1_clear_log/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"}],"title":"C++ 面向对象 virtual override final","date":"2020/05/05","text":"1. virtual 虚函数是可在子类中覆盖其行为的成员函数。 #include &lt;iostream&gt;struct Base &#123; virtual void f() &#123; std::cout &lt;&lt; &quot;base\\n&quot;; &#125;&#125;;struct Derived : Base &#123; void f() override &#123; // &#x27;override&#x27; 可选 std::cout &lt;&lt; &quot;derived\\n&quot;; &#125;&#125;;int main()&#123; Base b; Derived d; // 通过引用调用虚函数 Base&amp; br = b; // br 的类型是 Base&amp; Base&amp; dr = d; // dr 的类型也是 Base&amp; br.f(); // 打印 &quot;base&quot; dr.f(); // 打印 &quot;derived&quot; // 通过指针调用虚函数 Base* bp = &amp;b; // bp 的类型是 Base* Base* dp = &amp;d; // dp 的类型也是 Base* bp-&gt;f(); // 打印 &quot;base&quot; dp-&gt;f(); // 打印 &quot;derived&quot; // 非虚函数调用 br.Base::f(); // 打印 &quot;base&quot; dr.Base::f(); // 打印 &quot;base&quot;&#125; 2. override 指定一个虚函数覆盖另一个虚函数。 struct A&#123; virtual void foo(); void bar();&#125;; struct B : A&#123; void foo() const override; // 错误：B::foo 不覆盖 A::foo // （签名不匹配） void foo() override; // OK：B::foo 覆盖 A::foo void bar() override; // 错误：A::bar 非虚&#125;; 3. final 指定某个虚函数不能在子类中被覆盖，或者某个类不能被子类继承。 struct Base&#123; virtual void foo();&#125;; struct A : Base&#123; void foo() final; // Base::foo 被覆盖而 A::foo 是最终覆盖函数 void bar() final; // 错误： bar 不能为 final 因为它非虚&#125;; struct B final : A // struct B 为 final&#123; void foo() override; // 错误：foo 不能被覆盖，因为它在 A 中是 final&#125;; struct C : B // 错误：B 为 final&#123;&#125;;","permalink":"https://zengliangju.github.io/2020/05/05/c++/5_virtual_override_final/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"},{"name":"搜索","slug":"搜索","permalink":"https://zengliangju.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"Lucene","slug":"Lucene","permalink":"https://zengliangju.github.io/tags/Lucene/"}],"title":"Lucene C++ 版本实现（二）util","date":"2020/05/03","text":"","permalink":"https://zengliangju.github.io/2020/05/03/lucene_cpp/2_util/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"}],"title":"C++ map/set unordered_map/unordered_set 的区别","date":"2020/05/03","text":"注：下面的区别同样适用于 set 和 unordered_set 原理 map 基于红黑树（一种非严格意义上的平衡二叉树），使用 operator &lt; 比较元素大小，选择合适的位置插入到红黑树。这棵树能自动排序，因此 map 中的数据都是有序的。 unordered_map 基于哈希表。 时间复杂度 map 搜索、插入和移除：$$O(lg(n))$$ unordered_map 搜索、插入和移除：$$O(1)$$ 空间复杂度 map &gt; unordered_map 类比 java map ： java 中的 TreeMap unordered_map ： java 中的 HashMap 使用场景 map ： 需要对 map 进行有序遍历 unordered_map ： 仅需要查找，不需要有序遍历","permalink":"https://zengliangju.github.io/2020/05/03/c++/4_map_unordered_map/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"}],"title":"C++ dense_hash_map dense_hash_set","date":"2020/05/03","text":"void set_empty_key(const key_type&amp; key) 设置一个空 key ，必须在 dense_hash_map &#x2F; dense_hash_set 构造后立即执行，在其它 dense_hash_map &#x2F; dense_hash_set 操作前执行。 void set_deleted_key(const key_type&amp; key) 设置一个删除 key ，必须在调用 erase() 之前执行。","permalink":"https://zengliangju.github.io/2020/05/03/c++/3_dense_hash_map_set/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"}],"title":"C++ move","date":"2020/05/03","text":"举例： #include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::move#include &lt;vector&gt; // std::vector#include &lt;string&gt; // std::string int main()&#123; std::string str = &quot;Hello&quot;; std::vector&lt;std::string&gt; v; // 使用 push_back(const T&amp;) 重载， // 表示我们将带来复制 str 的成本 v.push_back(str); std::cout &lt;&lt; &quot;After copy, str is \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;\\n&quot;; // 使用右值引用 push_back(T&amp;&amp;) 重载， // 表示不复制字符串；而是 // str 的内容被移动进 vector // 这个开销比较低，但也意味着 str 现在可能为空。 v.push_back(std::move(str)); std::cout &lt;&lt; &quot;After move, str is \\&quot;&quot; &lt;&lt; str &lt;&lt; &quot;\\&quot;\\n&quot;; std::cout &lt;&lt; &quot;The contents of the vector are \\&quot;&quot; &lt;&lt; v[0] &lt;&lt; &quot;\\&quot;, \\&quot;&quot; &lt;&lt; v[1] &lt;&lt; &quot;\\&quot;\\n&quot;;&#125; 输出： After copy, str is &quot;Hello&quot;After move, str is &quot;&quot;The contents of the vector are &quot;Hello&quot;, &quot;Hello&quot;","permalink":"https://zengliangju.github.io/2020/05/03/c++/2_move/","photos":[]},{"tags":[],"title":"花终将开","date":"2020/05/02","text":"愿有情人终成眷属问世间情为何物，直教人生死相许！","permalink":"https://zengliangju.github.io/2020/05/02/readme/","photos":["/images/lover.jpeg"]},{"tags":[{"name":"Git","slug":"Git","permalink":"https://zengliangju.github.io/tags/Git/"}],"title":"Git 常用命令","date":"2020/05/02","text":"[TOC] 1. branch1.1 删除本地分支git branch -d branch_name 1.2 删除远程分支git branch -d -r origin/branch_name git push origin :branch_name 2. clone2.1 clone子模块git clone --recursive https://github.com/foo/bar.git 2.2 http clone带上密码git clone http://yourname:password@github.com/foo/bar.git 3. push gerrit3.1 不需要review（慎用）git push gerrit HEAD:refs/heads/master 3.2 需要reviewgit push gerrit HEAD:refs/for/master 4. rebase4.1 场景1 合并多次commit合并最近的4次commit git rebase -i HEAD~4 4.2 场景2 合并分支将当前分支合并进master分支 git rebase master 5. remote5.1 添加远程地址git remote add origin http://github.com/foo/bar.git 5.2 增加远程地址的时候带上密码git remote add origin http://yourname:password@git.oschina.net/name/project.git 5.3 删除远程地址git remote rm origin 5.4 重命名远程地址git remote rename origin gerrit 6. Taggit tag -l git tag -a v1.4 -m &#39;my version 1.4&#39; git push orign v1.4","permalink":"https://zengliangju.github.io/2020/05/02/git/all/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"},{"name":"搜索","slug":"搜索","permalink":"https://zengliangju.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"Lucene","slug":"Lucene","permalink":"https://zengliangju.github.io/tags/Lucene/"}],"title":"Lucene C++ 版本实现（一）前期准备","date":"2019/12/13","text":"项目启动传闻，Lucene创始人花了一下午时间，写出了第一版的Lucene。而作为普通人的我，不想只站在山底下仰望大佬，也想尽力去追赶他们的身影。于是，我便有了这个系列的想法，用C++去实现最早版本的Lucene。 Lucene 1.0.1https://github.com/apache/lucene-solr/tree/releases/lucene/1.0.1 目录结构build/include/lib/src/ analysis/ document/ index/ query_parser/ search/ store/ util/test/build.shCMakeLists.txt 编译命令cd build &amp;&amp; cmake . &amp;&amp; ./lucene_cpp &amp;&amp; cd .. 工具 c++ 11 cmake 3 gtest","permalink":"https://zengliangju.github.io/2019/12/13/lucene_cpp/1_startup/","photos":[]},{"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"}],"title":"C++ 智能指针","date":"2019/12/08","text":"C++ 11 智能指针 unique_ptr、shared_ptr 与 weak_ptrC++ 11 中有 unique_ptr、shared_ptr 与 weak_ptr 等智能指针（smart pointer），定义在 中，用于对动态资源进行管理，保证任何情况下，已构造的对象最终会销毁。 1. unique_ptrunique_ptr 持有对对象的独有权，同一时刻只能有一个 unique_ptr 指向给定对象。 实现方式举例2. shared_ptrshared_ptr 允许多个智能指针共享拥有同一堆分配对象的内存，一旦最后一个这样的指针被销毁，这个对象会被自动删除。 实现方式举例3. weak_ptrweak_ptr 可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，但并不拥有该内存，即 weak_ptr 的构造和析构不会增加和减少对象的引用计数。 实现方式举例4. auto_ptr已被 deprecated，被 unique_ptr 替代。 5. 总结","permalink":"https://zengliangju.github.io/2019/12/08/c++/1_smart_pointer/","photos":[]}],"categories":[],"tags":[{"name":"CPP","slug":"CPP","permalink":"https://zengliangju.github.io/tags/CPP/"},{"name":"Linux","slug":"Linux","permalink":"https://zengliangju.github.io/tags/Linux/"},{"name":"ES","slug":"ES","permalink":"https://zengliangju.github.io/tags/ES/"},{"name":"搜索","slug":"搜索","permalink":"https://zengliangju.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"Lucene","slug":"Lucene","permalink":"https://zengliangju.github.io/tags/Lucene/"},{"name":"Git","slug":"Git","permalink":"https://zengliangju.github.io/tags/Git/"}]}